################################################################################
# Imprimitive complex reflection groups
#
# Copyright (C) 2021 Ulrich Thiel, ulthiel.com/math
#
################################################################################
export ImprimitiveComplexReflectionGroup, order, rank, ngens, is_wellgenerated, degrees, exponents, codegrees, coexponents, num_reflections, num_classes_reflections, num_hyperplanes, coxeter_number, num_conjugacy_classes

import Nemo: ZZ, euler_phi


"""
    ImprimitiveComplexReflectionGroup

In the Shephard–Todd classification of irreducible complex reflection groups, the imprimitive ones are of the form G(m,p,n) for positive integers m,p,n satisfying the following conditions:
* p divides m
* n > 1 (otherwise not primitive)
* (m,p,n) ≠ (1,1,n) (otherwise not irreducible)
* (m,p,n) ≠ (2,2,2) (otherwise not irreducible)

So far, these groups are not implemented as groups but just as a structure carrying the integers m,p,n. This will be upgraded to an actual group once OSCAR has decided how to do that formally and I know what's the best way to do this. Nonetheless, we can deduce useful information from just the integers.

# Example
```julia-repl
julia> W=ImprimitiveComplexReflectionGroup(2,1,4) #The Weyl group B4
julia> order(W)
384
```
"""
struct ImprimitiveComplexReflectionGroup
	type::Tuple{T,T,T} where T<:Integer

	function ImprimitiveComplexReflectionGroup(type)
		m = type[1]
		p = type[2]
		n = type[3]

		# Argument checking to ensure group is irreducible and imprimitive
		m>0 || throw(ArgumentError("m>0 required"))
		p>0 || throw(ArgumentError("p>0 required"))
		n>1 || throw(ArgumentError("n>0 required"))
		m % p == 0 || throw(ArgumentError("m must divide p"))
		type != (1,1,n) || throw(ArgumentError("(m,p,n) ≠ (1,1,n) required"))
		type != (2,2,2) || throw(ArgumentError("(m,p,n) ≠ (2,2,2) required"))

		return new(type)
	end
end

function ImprimitiveComplexReflectionGroup(m::Integer, p::Integer, n::Integer)
	ImprimitiveComplexReflectionGroup((m,p,n))
end


"""
	order(W::ImprimitiveComplexReflectionGroup)

The order of the group W. For W=G(m,p,n) this is equal to (mⁿn!)/p.

# References
G. Lehrer and D. Taylor, *Unitary reflection groups*, Australian Mathematical Society Lecture Series, Vol 20, Cambridge University Press (2009), p274.
"""
function order(W::ImprimitiveComplexReflectionGroup)
	m = W.type[1]
	p = W.type[2]
	n = W.type[3]

	# See the book by Lehrer-Taylor, 274.
	return div(ZZ(m)^n*factorial(ZZ(n)), ZZ(p))
end


"""
	rank(W::ImprimitiveComplexReflectionGroup)

By defniniton, the **rank** of W=G(m,p,n) is the number n. This is also equal the dimension of one (any) irreducible reflection representation of W.
"""
function rank(W::ImprimitiveComplexReflectionGroup)

	return W.type[3]

end


"""
	ngens(W::ImprimitiveComplexReflectionGroup)

The cardinality of one (any) minimal generating set of W consisting of reflections of W. For W=G(m,p,n) this number is:
* n if p=1 or p=m
* n+1 otherwise.

# References
G. Lehrer and D. Taylor, *Unitary reflection groups*, Australian Mathematical Society Lecture Series, Vol 20, Cambridge University Press (2009), p35.
"""
function ngens(W::ImprimitiveComplexReflectionGroup)
	m = W.type[1]
	p = W.type[2]
	n = W.type[3]

	if p == 1 || p == m
		return n
	else
		return n+1
	end
end


"""
	is_wellgenerated(W::ImprimitiveComplexReflectionGroup)

The group W is called **well-generated** if it can be generated by n reflections, where n is the rank of W. By [`ngens(W::ImprimitiveComplexReflectionGroup)`](@ref) the group W=G(m,p,n) is well-generated if and only if p=1 or p=m.
"""
function is_wellgenerated(W::ImprimitiveComplexReflectionGroup)
	m = W.type[1]
	p = W.type[2]
	n = W.type[3]

	if p == 1 || p == m
		return true
	else
		return false
	end
end


"""
	degrees(W::ImprimitiveComplexReflectionGroup)

The **degrees** of W are the degrees of one (any) system of fundamental invariants of the invariant ring ℂ[V]ᵂ, where V is one (any) irreducible reflection representation of W and ℂ[V] is the symmetric algebra of the dual of V. We sort the degrees increasingly. For W=G(m,p,n) they are m, 2m, …, (n-1)m, and nm/p. We sort them increasingly.

# References
G. Lehrer and D. Taylor, *Unitary reflection groups*, Australian Mathematical Society Lecture Series, Vol 20, Cambridge University Press (2009), p274.
"""
function degrees(W::ImprimitiveComplexReflectionGroup)
	m = W.type[1]
	p = W.type[2]
	n = W.type[3]

	d = [ ZZ(i)*ZZ(m) for i=1:n-1 ]
	append!(d,[ZZ(n)*div(ZZ(m),ZZ(p))])
	sort!(d)

	return d
end


"""
	exponents(W::ImprimitiveComplexReflectionGroup)

The **exponents** of W are the integers mᵢ ≔ dᵢ-1, where the dᵢ are the degrees of W.
"""
function exponents(W::ImprimitiveComplexReflectionGroup)
	return [d-1 for d in degrees(W)]
end


"""
	codegrees(W::ImprimitiveComplexReflectionGroup)

The codegrees of W, sorted *decreasingly*. For W=G(m,p,n) they are:
* 0, m, 2m, …, (n-1)m if p ≠ m;
* 0, m, 2m, …, (n-2)m, (n-1)m - n if p=m.

# References
G. Lehrer and D. Taylor, *Unitary reflection groups*, Australian Mathematical Society Lecture Series, Vol 20, Cambridge University Press (2009), p274.
"""
function codegrees(W::ImprimitiveComplexReflectionGroup)
	m = W.type[1]
	p = W.type[2]
	n = W.type[3]

	if p != m
		c = [ ZZ(i)*ZZ(m) for i=0:n-1 ]
	else
		c = [ ZZ(i)*ZZ(m) for i=0:n-2 ]
		append!(c, [ZZ(n-1)*ZZ(m)-ZZ(n)])
	end

	sort!(c, rev=true)
	return c
end


"""
	coexponents(W::ImprimitiveComplexReflectionGroup)

The coexponents ``m_i^*`` of W are related to the codegrees ``d_i^*`` via ``m_i^* := d_i^* + 1``.
"""
function coexponents(W::ImprimitiveComplexReflectionGroup)
	return [d+1 for d in codegrees(W)]
end


"""
	num_reflections(W::ImprimitiveComplexReflectionGroup)

The number of (complex) reflections in W. This is equal to the sum over the exponents of W.

# References
G. Lehrer and D. Taylor, *Unitary reflection groups*, Australian Mathematical Society Lecture Series, Vol 20, Cambridge University Press (2009), Theorem 4.14.
"""
function num_reflections(W::ImprimitiveComplexReflectionGroup)
	m = W.type[1]
	p = W.type[2]
	n = W.type[3]

	#The following formula is true for any complex reflection group
	return sum([m for m in exponents(W)])
end


"""
	num_classes_reflections(W::ImprimitiveComplexReflectionGroup)

The number of conjugacy classes of (complex) reflections in W. For W=G(m,p,n) this is equal to:
* m/p if n>2, or n=2 and p is odd;
* m/p + 1 if n=2 and p is even.

# References
U. Thiel, *On restricted rational Cherednik algebras* (2014), Theorem 15.27.
"""
function num_classes_reflections(W::ImprimitiveComplexReflectionGroup)
	m = W.type[1]
	p = W.type[2]
	n = W.type[3]

	# See my thesis
	if n > 2 || (n==2 && isodd(p))
		return ZZ(div(m,p))
	else
		return ZZ(div(m,p) + 1)
	end
end


"""
	num_hyperplanes(W::ImprimitiveComplexReflectionGroup)

The number of reflecting hyperplanes (fixed spaces of complex reflections) of W. This is equal to the sum over the coexponents.
"""
function num_hyperplanes(W::ImprimitiveComplexReflectionGroup)

	return sum(coexponents(W))

end


"""
	coxeter_number(W::ImprimitiveComplexReflectionGroup)

The Coxeter number ``h`` of ``W`` is defined as
```math
h := \\frac{N+N^*}{n} \\;,
```
where ``N`` is the number of reflections, ``N^*`` is the number of reflecting hyperplanes, and ``n`` is the rank of ``W``.
"""
function coxeter_number(W::ImprimitiveComplexReflectionGroup)
	return div(num_reflections(W)+num_hyperplanes(W),ZZ(rank(W)))
end


"""
	num_conjugacy_classes(W::ImprimitiveComplexReflectionGroup)

The number of conjugacy classes of an Imprimitive Complex Reflection Group ``W`` is equal to the number of multipartitions if ``p=1``, otherwise do a weighted sum of the number of ``k``-stuttering ``m``-multipartitions of ``n`` with ``k \\mid gcd(n,p)``. A ``k``-stuttering multipartition ``\\lambda=(\\lambda^{(0)}, ..., \\lambda^{(m-1)})`` has the property ``\\lambda^{(i)} = \\lambda^{(i+k)}`` where the indexing is modulo ``m``.
Since this is also the number of irreducible complex representations of ``W``, one can refer to J. Stembridge [On the Eigenvalues of Representations of Reflection Groups and Wreath Products](https://msp.org/pjm/1989/140-2/pjm-v140-n2-p06-p.pdf), section 6.
"""

function num_conjugacy_classes(W::ImprimitiveComplexReflectionGroup)
	m = W.type[1]
	p = W.type[2]
	n = W.type[3]

	if p==1
		return num_multipartitions(n,m)
	end

	t=gcd(n,p)
	a=[]
	for k in 1:t
		if floor(t/k)!=t/k
			append!(a, 0)
		else
			append!(a, convert(Int64,num_multipartitions(n÷k,m÷k))) #implementation uses ::Nemo.fmpz, we convert back
		end
	end
	#now we have an array of all the number of k-stuttering multipartitions
	#before we count them up, we have to remove duplicates
	for k in 0:t-1
		if a[t-k] != 0
			for j in 2:t÷(t-k)
				a[t-k] = a[t-k] - a[j*(t-k)]
			end
		end
	end
	#now we have to weigh the summands by multiplying with the size of the stabilizer of the respective stuttering (which is i) and divide by the orbit size under C_p (which is p/i)
	res = sum([a[i]*i^2÷p for i in 1:t])
	return res
end
